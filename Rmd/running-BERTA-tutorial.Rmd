---
title: "Bayesian Estimation of Recruitment Trends in Alberta (BERTA) Tutorial"
author: "Christopher L. Cahill"
date: "31 December 2021"
output:
  pdf_document: default
  html_document: default
highlight: tango
---
# Goals
- Understand general structure of and build intuition for the age-structured population dynamics model used in Cahill et al. (2021).
- Gain an understanding of available modeling options, including tweaking priors and MCMC run parameters.
- Become familiar with tidyverse sub-setting, `get_fit()`, `future_pwalk()`, and `plan()`. 
- Learn how .R and .stan scripts are working together to subset data, fit a Bayesian stock reduction analysis model to those data, and then save the model fit with a unique file name identifier.
- Practice debugging using `browser()`.

# Packages 
Let's load the packages we will use:

```{r}
library(tidyverse)
library(rstan)
library(furrr)
library(future) 
library(ggplot2)
```

# Data
We will work with the Fall Walleye Index Netting (FWIN) dataset used in Cahill et al. (2021), which included all Alberta lakes with $\ge$ 3 FWIN surveys during 2000-2018.  Life history parameters $\omega$, $A_{50}$, $L_{\infty}$, $vbk$, and ${\beta}_{wl}$ were obtained using hierarchical modeling methods described in Cahill et al. (2020), and these values represent lake-specific averages. 

```{r}
data <- readRDS(here::here("data/BERTA-wide-0-25.rds"))
glimpse(data)
```

Now read in the stocking data, which was used for plotting and not fitted in the .stan model.  Note these stocking records go from 1980-2018, and values represent the number of Walleye stocked per hectare: 

```{r}
stocking <- readRDS(here::here("data/stocking_matrix_ha.rds"))
glimpse(stocking)
```

# Create a wrapper function
Once the data are read into R, we can write a wrapper function called `get_fit()` that does the following:

- subsets all the data to data for a specific lake
- creates the appropriate tagged list data structures as input into the Stan model
- creates appropriate input for parameters for our Stan model 
- runs the stan model for a particular combination of priors (e.g., which ${\alpha}_{r}$), structural control parameters (e.g., Ricker vs. Beverton-Holt stock-recruit), and Stan run parameter values (i.e., how many iterations, warmup, chains?) 
- saves this model run with a clever name (e.g., `pigeon_lake_ricker_cr6.rds`)

This may seem like a pain, but coding this way will help us later on when we need to run multiple models on different data sets.  

```{r}
get_fit <- function(which_lake = "pigeon lake",
                    rec_ctl = c("bev-holt", "ricker"),
                    cr_prior = c(6, 12),
                    n_iter = n_iter, n_chains = n_chains,
                    n_warmup = n_iter / 2,
                    ...) {
  # Some outrageous amount of code here in the run.R script
}
```

There is too much code in this chunk to show here.  Let's break `get_fit()` down into pieces.  Note these next lines won't run because we are jumping inside a function (thus your machine won't be able to find certain parameters). 

The first few lines of `get_fit()` are: 

```{r, eval = FALSE}

rec_ctl <- match.arg(rec_ctl)
cat(
    crayon::green(
      clisymbols::symbol$tick
    ),
    fitted = "model fitted = ", which_lake, rec_ctl, 
    sep = " "
)
cat("\n")
```

This code looks scary but it is simply ensuring that the variable rec_ctl is either "ricker" or "bev-holt" via `match_arg()`.  Next, this code is printing which lake and recruitment model is being fitted to the console via cat(). This isn't super important and realistically can be omitted or ignored by most users.

The next chunk of code is: 

```{r, eval = FALSE}
#filter the run data from all data, re-order it 
run_data <- data %>% filter(name %in% which_lake)
 run_data <-
    within(run_data, lake <-
      as.numeric(interaction(
        run_data$WBID,
        drop = TRUE, lex.order = F
    )))
run_data <- run_data[order(run_data$lake), ]
```

This first line subsets all available data via `%>%` and `filter()`, and returns data corresponding to the variable `which_lake`.  

The next few lines of code are simply re-ordering the data to ensure FWIN catch data for a given lake are in ascending order in terms of years via `within()` and `order()`  